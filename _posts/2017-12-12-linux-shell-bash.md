---
title: Linux shell(bash)学习笔记
layout: post
date:   2017-12-12 16:55:11 +0800
categories: learn linux
---

# 特殊符号

符号 | 作用 | 样例 | 说明
--- | --- | --- | ---
`$` | 引用变量 |   `x=12`         ##等号左右不能有空格 `echo $x` | 一些重要变量`$HOME` 当前用户主目录 `$PATH` 搜索目录`$PS1` 命令提示符`$PS2` 二级提示符
`$IFS` | shell输入分隔符 |  | 通常为空格、制表符和换行符
`$#` | 参数个数
`$0` | shell脚本名字
`$1,$2,$n` | 第1,2,n个参数
`$*` | 所有参数，用IFS中的第一个字符分隔
`$@` | 类似$*，但不使用IFS字符分隔
`$?` |  前条命令的退出状态`0(true) 1(false)`
单引号 - \' | 当shell碰到第一个单引号时，它忽略掉其后直到右引号的所有特殊字符
双引号 -  \" | 双引号作用与单引号类似，区别在于它没有那么严格。 |  | 单引号告诉shell忽略所有特殊字符，而双引号中的三种特殊字符不被忽略：`$`, \\, \`,即双引号会解释字符串的特别意思,而单引号直接使用字符串。
反引号\` 或$() | 命令替换 |  | `$()`格式受到POSIX标准支持,`$(command)`,执行命令并捕获其输出,输可以放到变量中,如下面的expr例子`x=$(expr $x + 1)`
 ( )  |   ①命令组②命令替换③用于初始化数组   |  | ①命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。②命令替换,$(cmd)。等同于`cmd`，shell扫描一遍命令行，发现了，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。③用于初始化数组。如：array=(a b c d)
(( )) 或let | 算术赋值，用来给表达式赋值并返回一个状态码。利用算术赋值可以进行赋值运算及逻辑比较 | `((x=x+1)) ## x=$((x+1))``if ((30 < age && age < 60)); then` |  ①整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是"假"，而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为1,假则为0。 ②只要括号中的运算符、表达式符合C语言运算规则，都可用在`$((exp))`中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：`echo $((16#5f))` 结果为95 (16进位转十进制) ③单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 `$a` 重定义为6 ④双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。
$(( )) | 算术扩展，用于显示表达式的值或者把值赋给一个变量，可替代expr命令,比expr更高效. |   | `x=$(($x+1))`##$(( ))中单个变量引用$符可选，即可写成 `x=$((x+1))` `x=$(expr $x + 1)`  ##加号左右要有空格 `expr $x + 1` 执行结果捕获其输出放到变量
[ ] 或test | 条件判断 |  | ①bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。  `if [ -f fred.c ]`  ##要有空格  `if [ 30 -lt $age -a $age -lt 60 ]; then`②Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：[ ab \< bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。 ③字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。 ④在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。
[[ ]] |  |  |  ①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。  ②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。 ③使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如， `&&`、\|\| 、`<`和`>`操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。      ④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。 作用与[ ]类似，操作符不同，与C语言操作一致 `if [[ 30 < $age && $age < 60 ]]; then`   ##要有空格,变量前要有$
&& \|\|及\! |  |  |   `statement1 && statement2 && statement3`，上一条命令返回true才执行下一条；\|\|类似   `if [ -f fred.c ] && echo 'exists' && [ -f fred.h ]`   ## echo 返回的是true
 {}常规用法 |  |  |     ①大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。 对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt②代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。
 {}特殊用法 |  |  |        用于字符串截断取子串等。例如：`${var:-string}`、`${var#*/}`、`${var%%.*}`、`${var:5:5}`等。
\: 冒号 | 空命令，返回true
`<<` |  交互式程序多行输入 | sqlplus / as sysdba <<EOFstartup;exit;EOF | ”EOF“通常与”<<“结合使用，“<<EOF“表示后续的输入作为子命令或子shell的输入，直到遇到”EOF“，再次返回到主调shell，可将其理解为分界符（delimiter）。

# 比较操作符

>二元比较操作符用来比较两个变量或数字. 注意整数比较与字符串比较的区别.

## 整数比较

操作符 | 作用 | 样例 | 说明
--- | --- | --- | ---
-eq | 等于 | `if [ "$a" -eq "$b" ]` | equal
-ne | 不等于 | `if [ "$a" -ne "$b" ]` | not equal
-gt | 大于 | `if [ "$a" -gt "$b" ]` | great than
-ge | 大于等于 | `if [ "$a" -ge "$b" ]`
-lt | 小于 | `if [ "$a" -lt "$b" ]`
-le | 小于等于 | `if [ "$a" -le "$b" ]`
\< | 小于(在双括号中使用) | `(("$a" < "$b"))`
<= | 小于等于(在双括号中使用) | `(("$a" <= "$b"))`
\> | 大于(在双括号中使用) | `(("$a" > "$b"))`
`>=` | 大于等于(在双括号中使用) | `(("$a" >= "$b"))`

## 字符串比较

操作符 | 作用 | 样例 | 说明
--- | --- | --- | ---
= | 等于 | `if [ "$a" = "$b" ]`
== | 等于 | `if [ "$a" == "$b" ]` | 与=等价.==比较操作符在双中括号对和单中括号对中的行为是不同的.
!= | 不等号 | `if [ "$a" != "$b" ]` | 这个操作符将在`[[ ... ]]`结构中使用模式匹配.
\< | 小于, 按照ASCII字符进行排序 | `if [[ "$a" < "$b" ]]``if [ "$a" \< "$b" ]` | 注意"<"使用在 `[...]` 结构中的时候需要被转义.
`>` | 大于, 按照ASCII字符进行排序 | `if [[ "$a" > "$b" ]]``if [ "$a" \> "$b" ]` | 注意">"使用在 `[...]` 结构中的时候需要被转义.
-z | 字符串为"null", 意思就是字符串长度为零
-n | 字符串不为"null". |  | 当 -n 使用在中括号中进行条件测试的时候, 必须要把字符串用双引号引用起来. 如果采用了未引用的字符串来使用 `! -z` , 甚至是在条件测试中括号中只使用未引用的字符串的话, 一般也是可以工作的, 然而,这是一种不安全的习惯. 习惯于使用引用的测试字符串才是正路. 

- 注意事项1: `==`双中括号对和单中括号对中的行为区别

```bash
 [[ $a == z* ]]  # 如果$a以"z"开头(模式匹配)那么结果将为真
 [[ $a == "z*" ]] # 如果$a与z*相等(就是字面意思完全一样), 那么结果为真.

 [ $a == z* ]  # 文件扩展匹配(file globbing)和单词分割有效.
 [ "$a" == "z*" ] # 如果$a与z*相等(就是字面意思完全一样), 那么结果为真.
```

- 注意事项2
 **在一个混合测试中, 即使使用引用的字符串变量也可能还不够.如果 `$string` 为空的话, `[ -n "$string" -o "$a" = "$b" ]` 可能会在某些版本的Bash中产生错误. 安全的做法是附加一个额外的字符给可能的空变量, `[ "x$string" != x -o "x$a" ="x$b" ]` ("x"字符是可以相互抵消的).**

# 文件测试操作符

操作符 | 作用 | 样例 | 说明
--- | --- | --- | ---
-e | 文件存在 |  | exist
-a | 文件存在 |  | 这个选项的效果与-e相同. 但是它已经被"弃用"了, 并且不鼓励使用.
-f | 一般 文件 |  | 表示这个文件是一个 一般 文件(并不是目录或者设备文件)
-s | 文件大小不为零
-d | 表示这是一个目录 |  | directory
-b | 表示这是一个块设备(软盘, 光驱, 等等.) |  | block
-c | 表示这是一个字符设备(键盘, modem, 声卡, 等等.)
-p | 这个文件是一个管道
-h | 这是一个符号链接
-L | 这是一个符号链接
-S | 表示这是一个socket
-t | 文件(描述符)被关联到一个终端设备上 |  | 这个测试选项一般被用来检测脚本中的 stdin ( [终端.-t 0 ] )或者stdout ( [-t 1 ] )是否来自于一个
-r | 文件是否具有可读权限 |  | ( 指的是正在运行这个测试命令的用户是否具有读权限)
-w | 文件是否具有可写权限 |  | (指的是正在运行这个测试命令的用户是否具有写权限)
-x | 文件是否具有可执行权限 |  | (指的是正在运行这个测试命令的用户是否具有可执行权限)
-O | 判断你是否是文件的拥有者
-G | 文件的group-id是否与你的相同
-N | 从文件上一次被读取到现在为止, 文件是否被修改过
-nt | 文件较新 - newer than | f1 -nt f2 | 文件 f1 比文件 f2 新
-ot | 文件较旧 - older than | f1 -ot f2 | 文件 f1 比文件 f2 旧
-ef | 硬链接 | f1 -ef f2 | 文件 f1 和文件 f2 是相同文件的硬链接
! | "非"  |  | 反转上边所有测试的结果(如果没给出条件, 那么返回真).

# 文件测试高级操作符

操作符 | 作用 | 说明
--- | --- | ---
-g | set-group-id(sgid)标记被设置到文件或目录上 | 如果目录具有 sgid 标记的话, 那么在这个目录下所创建的文件将属于拥有这个目录的用户组, 而不必是创建这个文件的用户组. 这个特性对于在一个工作组中共享目录非常有用.
-u | set-user-id (suid)标记被设置到文件上 | 如果一个root用户所拥有的二进制可执行文件设置了 set-user-id 标记位的话, 那么普通用户也会以root权限来运行这个文件. [1] 这对于需要访问系统硬件的执行程序(比如pppd和cdrecord)非常有用. 如果没有suid标志的话, 这些二进制执行程序是不能够被非root用户调用的.例如`-rwsr-xr-t /usr/sbin/pppd`，对于设置了 suid 标志的文件, 在它的权限列中将会以s 表示.
-k | 设置 粘贴位 | 对于"粘贴位"的一般了解, save-text-mode标志是一个文件权限的特殊类型. 如果文件设置了这个标志, 那么这个文件将会被保存到缓存中, 这样可以提高访问速度. [2] 粘贴位如果设置在目录中, 那么它将限制写权限. 对于设置了粘贴位的文件或目录, 在它们的权限标记列中将会显示t .例如：`drwxrwxrwt tmp/`，如果用户并不拥有这个设置了粘贴位的目录, 但是他在这个目录下具有写权限, 那么这个用户只能在这个目录下删除自己所拥有的文件. 这将有效的防止用户在一个公共目录中不慎覆盖或者删除别人的文件. 比如说 /tmp 目录. (当然, 目录的所有者或者 root用户可以随意删除或重命名其中的文件.)

# 逻辑操作符

操作符 | 作用 | 样例 | 说明
--- | --- | --- | ---
&& | 与
\|\| | 或
-a | 逻辑与 and | `exp1 -a exp2` | 如果表达式exp1和exp2都为真的话, 那么结果为真.
-o | 逻辑或 or | `exp1 -o exp2` | 如果表达式exp1和exp2中至少有一个为真的话, 那么结果为真.

- **&&和\|\|操作符是用在双中括号结构中的.**
 `[[ condition1 && condition2 ]]`
- **-o和-a操作符一般都是和test命令或者是单中括号结构一起使用的.**
 `if [ "$exp1" -a "$exp2" ]`

# 变量赋值操作符

操作符 | 作用 | 样例 | 说明
--- | --- | --- | ---
`$` `${}` |  | `${var}` |     变量var的值, 与$var相同
\- |  | `${var-DEFAULT}` |      如果var没有被声明, 那么就以$DEFAULT作为其值 *
:- |  | `${var:-DEFAULT}` |      如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 *
= |  | `${var=DEFAULT}` |      如果var没有被声明, 那么就以$DEFAULT作为其值 *
:= |  | `${var:=DEFAULT}` |      如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 *
\+ |  | `${var+OTHER}` |     如果var声明了, 那么其值就是$OTHER, 否则就为null字符串
:+ |  | `${var:+OTHER}` |      如果var被设置了, 那么其值就是$OTHER, 否则就为null字符串
? |  | `${var?ERR_MSG}` |      如果var没被声明, 那么就打印$ERR_MSG *
:? |  | `${var:?ERR_MSG}` |      如果var没被设置, 那么就打印$ERR_MSG *
`!...*` |  | `${!varprefix*}` |      匹配之前所有以varprefix开头进行声明的变量
`!...@` |  | `${!varprefix@}` |      匹配之前所有以varprefix开头进行声明的变量

# 字符串操作符（长度，读取，替换）

操作符 | 作用 | 样例 | 说明
--- | --- | --- | ---
`#` |  | `${#string}` | $string的长度
`:` |  | `${string:position}` |     在`$string`中, 从位置`$position`开始提取子串
`:...:` |  | `${string:position:length}` |     在`$string`中, 从位置`$position`开始提取长度为`$length`的子串
`#` |  | `${string#substring}` |     从变量`$string`的开头, 删除最短匹配`$substring`的子串
`##` |  | `${string##substring}` |     从变量`$string`的开头, 删除最长匹配`$substring`的子串
`%` |  | `${string%substring}` |     从变量`$string`的结尾, 删除最短匹配`$substring`的子串
`%%` |  | `${string%%substring}` |     从变量`$string`的结尾, 删除最长匹配`$substring`的子串
`/.../` |  | `${string/substring/replacement}` |     使用`$replacement`, 来代替第一个匹配的`$substring`
`//.../` |  | `${string//substring/replacement}` |     使用`$replacement`, 代替所有匹配的`$substring`
`/#.../` |  | `${string/#substring/replacement}` |     如果`$string`的前缀匹配`$substring`, 那么就用`$replacement`来代替匹配到的`$substring`
`/%.../` |  | `${string/%substring/replacement}` |     如果`$string`的后缀匹配`$substring`, 那么就用`$replacement`来代替匹配到的`$substring`

- **说明：`* $substring`可以是一个正则表达式.**(仅支持`?` `*`通配符表达式)

# 字符串操作符（Bash-4.0）

操作符 | 作用 | 样例 | 说明
--- | --- | --- | ---
`^` `^^` | Convert to Uppercase | `${var^PATTERN}` | The first character of var is converted to uppercase if it matches PATTERN; with a double caret (^^), it converts all characters matching PATTERN. If PATTERN is omitted, all characters are matched:
`,` `,,` | Convert to Lowercase | `${var,PATTERN}` | This expansion works in the same way as the previous one, except that it converts uppercase to lowercase:

# 其它操作符

操作符 | 作用 | 样例 | 说明
--- | --- | --- | ---
`,` | 连接多个算术运算，返回最后一个操作的结果 | let "t1 = ((5 + 3, 7 - 1, 15 - 4))" | # t1 = 11

# 算术运算

1. `let "a=1+2"`, `let "b = a*2"`, `let "b = $a*2"`
1. `(( a=1+2 ))`, `(( b=a+1 ))`, `(( b=$a+1 ))`
1. `a=$(( 1+2 ))`
1. `let "n++"`, `(( n++ ))`, `$(( n++ ))` , `$[ n++ ]` , `$[[ ++n ]]`

# bash中命令行扩展顺序

1. 花括号扩展 rm {main,temp,test}.c
1. 代字符扩展 `echo ~`
1. 参数扩展和变量扩展 `$a`
1. 算术扩展`x=$(($x+1))`
1. 命令替换`$(command)`
1. 分词 IFS
1. 路径名
1. 处理替换